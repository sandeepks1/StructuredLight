/*
-----------------------------------------------------------------------------
Filename:    StructuredLight.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC10 (July 2011)
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/
#include "stdafx.h"
#include "StructuredLight.h"
#include "serialLuminance.h"
using namespace Ogre;

#define VIDEO_PATH "..\\debug\\Data\\yatay_1.mov"
//#define VIDEO_PATH "tanitim d.mpg"

//-------------------------------------------------------------------------------------
StructuredLight::StructuredLight(void)
{
}
//-------------------------------------------------------------------------------------
StructuredLight::~StructuredLight(void)
{
	cvReleaseCapture(&videoCapture);
}



void StructuredLight::convertIplToTexture(IplImage* img,TexturePtr texture)
{
	HardwarePixelBufferSharedPtr pixelBuffer = texture->getBuffer();//Get the Pixel Buffer for Texture
	pixelBuffer->lock(HardwareBuffer::HBL_DISCARD);						//Lock the buffer
	const PixelBox& pixelBox = pixelBuffer->getCurrentLock();			//Get the pixel box for data pointer
	unsigned char* pDest = static_cast<unsigned char*>(pixelBox.data);
	unsigned char* videoPtr=(unsigned char*)(img->imageData);		//Get the pointer to the video frame

	for (int r=0;r<videoHeight;r++)
	{
		for(int c=0;c<videoWidth;c++)
		{
			for (int p=0;p<pix_size;p++)
				*(pDest++)=*(videoPtr++);//Copy the data
			if(pix_size==3)			//Ogre uses 4 bytes per pixel, so add an additional pass if video is RGB
				pDest++;
		}
		pDest+=empty_byte;			//If there are empty bytes at the end of the rows, add them to go to the correct location
		videoPtr+=empty_byte;
	}
	pixelBuffer->unlock();//Unlock the pixel buffer
	

}

void StructuredLight::reloadVideo()
{
	cvReleaseCapture(&videoCapture);
	videoCapture=cvCreateFileCapture(VIDEO_PATH);
}

void StructuredLight::SetupVideoMaterial()
{
	videoCapture=cvCreateFileCapture(VIDEO_PATH);
	PixelFormat pix_format;
	passedTime=0;
	videoWidth=0;
	if (videoCapture)
	{
		videoWidth=cvGetCaptureProperty(videoCapture,CV_CAP_PROP_FRAME_WIDTH);	//Get video properties
		videoHeight=cvGetCaptureProperty(videoCapture,CV_CAP_PROP_FRAME_HEIGHT);
		videoFPS=cvGetCaptureProperty(videoCapture,CV_CAP_PROP_FPS);
		frameDelay=1000/videoFPS;
		IplImage* nextFrame=cvQueryFrame(videoCapture);	//Get the pixel size
		pix_size = (nextFrame->depth & 255) >> 3;
		if( nextFrame->dataOrder == 0 )
		   pix_size *= nextFrame->nChannels;
		int row_w=nextFrame->width*pix_size;		//Get the row width and empty byte count
		empty_byte=nextFrame->widthStep-row_w;
		if (pix_size==3)
		{
			pix_format=PF_BYTE_BGR;
		}
		else if (pix_size==4)
		{
			pix_format=PF_BYTE_BGRA;
		}
		//cvReleaseImage(&nextFrame);

	}	

	// Create the texture
	if (videoWidth>0)
	{

		if (!TextureManager::getSingleton().resourceExists("VideoTexture"))
		{
		videoTexture = TextureManager::getSingleton().createManual(
				"VideoTexture", // name
				ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
				TEX_TYPE_2D,      // type
				videoWidth, videoHeight,         // width & height
				0,                // number of mipmaps
				pix_format,     // pixel format
				TU_DYNAMIC_WRITE_ONLY_DISCARDABLE);
		}

		// Create a material using the texture
		if (!MaterialManager::getSingleton().resourceExists("VideoMaterial"))
		{
			MaterialPtr material = MaterialManager::getSingleton().create(
					"VideoMaterial", // name
					ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
			material->getTechnique(0)->getPass(0)->createTextureUnitState("VideoTexture");
		}

	}

}

void StructuredLight::createStructuredTexture()
{
	// Create the texture
	if (!TextureManager::getSingleton().resourceExists("StructuredTexture"))
	{
	structuredTexture = TextureManager::getSingleton().createManual(
			"StructuredTexture", // name
			ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
			TEX_TYPE_2D,      // type
			m_Width, m_Height,         // width & height
			0,                // number of mipmaps
			PF_B8G8R8A8,     // pixel format
			TU_DYNAMIC_WRITE_ONLY_DISCARDABLE);
	
	}
	
	// Create a material using the texture
	if (!MaterialManager::getSingleton().resourceExists("StructuredMaterial"))
	{
		MaterialPtr material = MaterialManager::getSingleton().create(
				"StructuredMaterial", // name
				ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
		material->getTechnique(0)->getPass(0)->createTextureUnitState("StructuredTexture");
		//material->getTechnique(0)->getPass(0)->getTextureUnitState(0)->set;
		material->setTextureFiltering(Ogre::TFO_TRILINEAR);
		material->setCullingMode(Ogre::CULL_NONE);
		
	}

}

int getMaxPower(int raw)
{
	int power=0;

	while(pow((float)2,(int)power)<=raw)
		power++;
	
	return power;
}

int getPowerOfTwo(int raw)
{
	int power=0;

	while(pow((float)2,(int)power)<=raw)
		power++;

	return (int)(pow((float)2,(int)power));
}

void StructuredLight::refillTexture(bool verticalOrHorizontal,int divider)
{

	HardwarePixelBufferSharedPtr pixelBuffer = structuredTexture->getBuffer();//Get the Pixel Buffer for Texture
	pixelBuffer->lock(HardwareBuffer::HBL_DISCARD);						//Lock the buffer
	const PixelBox& pixelBox = pixelBuffer->getCurrentLock();			//Get the pixel box for data pointer
	unsigned char* pDest = static_cast<unsigned char*>(pixelBox.data);
	



	if (verticalOrHorizontal)
	{
		int lineHeight=m_Height/pow((float)2,(int)divider);
		char target=0;
		for (int r=0;r<m_Height;r++)
		{
			pDest = static_cast<unsigned char*>(pixelBox.data) + r*pixelBox.rowPitch*4;
			
			for(int c=0;c<m_Width;c++)
			{
				for (int k=0;k<4;k++)
				*(pDest++)=target;//Copy the data
			}
			if ((r+1)%lineHeight==0)
		
				target=255-target;

		}
		pixelBuffer->unlock();//Unlock the pixel buffer
	}
	else
	{
		int lineWidth=m_Width/pow((float)2,(int)divider);
		for (int r=0;r<m_Height;r++)
		{
			pDest = static_cast<unsigned char*>(pixelBox.data) + r*pixelBox.rowPitch*4;
			char target=0;
			for(int c=0;c<m_Width;c++)
			{
				for (int k=0;k<4;k++)
				*(pDest++)=target;//Copy the data
				if ((c+1)%lineWidth==0)
					target=255-target;

			}


		}
		pixelBuffer->unlock();//Unlock the pixel buffer

	}




}

void StructuredLight::mapPlane()
{

int	x1=0,
	x2=initialWidth,
	x3=initialWidth,
	x4=0,
	y1=0,
	y2=0,
	y3=initialHeight,
	y4=initialHeight,
	X1=points.at(0)->x,
	X2=points.at(1)->x,
	X3=points.at(2)->x,
	X4=points.at(3)->x,
	Y1=points.at(0)->y,
	Y2=points.at(1)->y,
	Y3=points.at(2)->y,
	Y4=points.at(3)->y;

	CvMat* bigM=cvCreateMat(8,9, CV_32FC1 );
	CvMat* bigMT=cvCreateMat(9,8, CV_32FC1 );
	CvMat* realT=cvCreateMat(9,9,CV_32FC1);
	CvMat* eigenVectors=cvCreateMat(9,9,CV_32FC1);
	CvMat* eigenValues=cvCreateMat(1,9,CV_32FC1);
	CvMat* homograph=cvCreateMat(3,3,CV_32FC1);
	CvMat* view=cvCreateMat(4,4,CV_32FC1);
	CvMat* invView=cvCreateMat(4,4,CV_32FC1);
	CvMat* trans=cvCreateMat(4,4,CV_32FC1);
	CvMat* final=cvCreateMat(4,4,CV_32FC1);
	cvZero(trans);


	float data1[]={X1,Y1,1,0,0,0,-X1*x1,-Y1*x1,-x1};
	float data2[]={0,0,0,X1,Y1,1,-X1*y1,-Y1*y1,-y1};
	float data3[]={X2,Y2,1,0,0,0,-X2*x2,-Y2*x2,-x2,};
	float data4[]={0,0,0,X2,Y2,1,-X2*y2,-Y2*y2,-y2};
	float data5[]={X3,Y3,1,0,0,0,-X3*x3,-Y3*x3,-x3};
	float data6[]={0,0,0,X3,Y3,1,-X3*y3,-Y3*y3,-y3};
	float data7[]={X4,Y4,1,0,0,0,-X4*x4,-Y4*x4,-x4};
	float data8[]={0,0,0,X4,Y4,1,-X4*y4,-Y4*y4,-y4};



	float* data[]={data1,data2,data3,data4,data5,data6,data7,data8};

	for (int i=0;i<8;i++)
	{
		for (int j=0;j<9;j++)
		{
			cvSet2D(bigM,i,j,cvScalar(data[i][j]));
		}
	}

	cvTranspose(bigM,bigMT);
	cvGEMM(bigMT,bigM,1,NULL,0,realT,0);
	cvEigenVV(realT,eigenVectors,eigenValues);
	
	for (int i=0;i<3;i++)
	{
		for (int j=0;j<3;j++)
		{
			cvSet2D(homograph,i,j,cvGet2D(eigenVectors,8,3*i+j));
		}
	}


	cvInvert(homograph,homograph);
	cvTranspose(homograph,homograph);


	for (int i=0;i<2;i++)
	{
		for (int j=0;j<2;j++)
		{
			cvSet2D(trans,i,j,cvGet2D(homograph,j,i));
		}
	}

	cvSet2D(trans,2,2,cvScalar(1));
	cvSet2D(trans,0,3,cvGet2D(homograph,2,0));
	cvSet2D(trans,1,3,cvGet2D(homograph,2,1));
	cvSet2D(trans,3,3,cvGet2D(homograph,2,2));
	cvSet2D(trans,3,0,cvGet2D(homograph,0,2));
	cvSet2D(trans,3,1,cvGet2D(homograph,1,2));


	Ogre::Matrix4 viewMat=mCamera->getViewMatrix();
	float eVal;
	for (int i=0;i<4;i++)
	{
		for (int j=0;j<4;j++)
		{
			eVal=viewMat[i][j];
			if (eVal<0.001 && eVal>-0.001)
				cvSet2D(view,i,j,cvScalar(0));
			else
				cvSet2D(view,i,j,cvScalar(viewMat[i][j]));
		}
	}
	
	cvInvert(view,invView);
	cvGEMM(trans,invView,1,NULL,1,final);
	cvGEMM(view,final,1,NULL,1,final);

	Ogre::Matrix4 homography=Ogre::Matrix4::ZERO;

	for (int i=0;i<4;i++)
	{
		for (int j=0;j<4;j++)
		{
			homography[i][j]=cvGetReal2D(final,i,j);
		}
	}
	
	if (homography[0][0]<0)
	{
		for (int i=0;i<4;i++)
			for (int j=0;j<4;j++)
				homography[i][j]=-homography[i][j];
	}
	

	trueProjection=mCamera->getProjectionMatrix();
	Ogre::Matrix4 mX=trueProjection*homography;
	mCamera->setCustomProjectionMatrix(true,mX);

	#if 1-SENSOR_INPUT
	currentTarget=0;
	#endif
	
	cvReleaseMat(&bigM);
	cvReleaseMat(&bigMT);
	cvReleaseMat(&realT);
	cvReleaseMat(&eigenVectors);
	cvReleaseMat(&eigenValues);
	cvReleaseMat(&homograph);
	cvReleaseMat(&view);
	cvReleaseMat(&invView);
	cvReleaseMat(&trans);
	cvReleaseMat(&final);

}
Ogre::SceneNode* borderNode;
void StructuredLight::createScene(void)
{

	initialWidth=m_Width;
	initialHeight=m_Height;
    // Set ambient light
    mSceneMgr->setAmbientLight(Ogre::ColourValue(1.0, 1.0, 1.0));

	maxPowerX=getMaxPower(m_Width);
	maxPowerY=getMaxPower(m_Height);

	m_Width=getPowerOfTwo(m_Width);
	m_Height=getPowerOfTwo(m_Height);

	createStructuredTexture();

	refillTexture(false,0);

	currentX=1;
	currentY=1;
	start=false;
	currentTarget=0;
	targetX=0;
	targetY=0;

	topLeft.x=0;
	topLeft.y=0;
	topRight.x=0;
	topRight.y=0;
	bottomRight.x=0;
	bottomRight.y=0;
	bottomLeft.x=0;
	bottomLeft.y=0;
	targetCorner=0;

	points.push_back(&topLeft);
	points.push_back(&topRight);
	points.push_back(&bottomRight);
	points.push_back(&bottomLeft);
	
	structurePanel=Ogre::OverlayManager::getSingleton().createOverlayElement("Panel","StructuredOverlay");
	structurePanel->setMaterialName("StructuredMaterial");
	structurePanel->setMetricsMode(Ogre::GMM_PIXELS);
	structurePanel->setWidth(m_Width);
	structurePanel->setHeight(m_Height);
	structurePanel->setHorizontalAlignment(GHA_LEFT);
	structurePanel->setVerticalAlignment(GVA_TOP);
	mTrayMgr->getTraysLayer()->add2D((Ogre::OverlayContainer*)structurePanel);
	structurePanel->hide();


	trueProjection=mCamera->getProjectionMatrix();

	points.at(0)->x=-5;
	points.at(0)->y=48;
	points.at(1)->x=1254;
	points.at(1)->y=36;
	points.at(2)->x=1253;
	points.at(2)->y=528;
	points.at(3)->x=32;
	points.at(3)->y=541;
	mapPlane();

	/*points.at(0)->x=0;
	points.at(0)->y=0;
	points.at(1)->x=0;
	points.at(1)->y=0;
	points.at(2)->x=0;
	points.at(2)->y=1009;
	points.at(3)->x=-55;
	points.at(3)->y=973;*/



	baseNode=mSceneMgr->getRootSceneNode()->createChildSceneNode("base");

	float mod=0.85;
	SetupVideoMaterial();
	videoMesh=MeshManager::getSingleton().createPlane("videoWall", ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
		Plane(-Vector3::UNIT_Z, 0),videoWidth*initialHeight/videoHeight, initialHeight, 1, 1, true, 1, 1, 1, -Vector3::UNIT_Y);
	videoNode=baseNode->createChildSceneNode("wallNode",Vector3(videoWidth*initialHeight/videoHeight/2,initialHeight/2,0));
	//videoMesh=MeshManager::getSingleton().createPlane("videoWall", ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
	//	Plane(-Vector3::UNIT_Z, 0),videoWidth*mod, videoHeight*mod, 1, 1, true, 1, 1, 1, -Vector3::UNIT_Y);
	//videoNode=baseNode->createChildSceneNode("wallNode",Vector3(videoWidth*mod/2+150,videoHeight*mod/2-130
	//	,0));
	videoWall = mSceneMgr->createEntity("video","videoWall");
	videoWall->setMaterialName("VideoMaterial");
	videoNode->attachObject(videoWall);


	Ogre::MeshPtr borderMesh=MeshManager::getSingleton().createPlane("borders", ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
		Plane(-Vector3::UNIT_Z, 0),initialWidth, initialHeight, 1, 1, true, 1, 1, 1, -Vector3::UNIT_Y);
	borderNode=baseNode->createChildSceneNode("borderNode",Vector3(initialWidth/2,initialHeight/2,-10));
	Ogre::Entity* borderLine = mSceneMgr->createEntity("borderLine","borders");
	borderLine->setMaterialName("border_mat_line");
	borderNode->attachObject(borderLine);





	/*qrMesh=MeshManager::getSingleton().createPlane("qrWall", ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
		Plane(-Vector3::UNIT_Z, 0),192, 192, 1, 1, true, 1, 1, 1, -Vector3::UNIT_Y);

	Ogre::SceneNode* tNode=baseNode->createChildSceneNode("qrNode1",Vector3(initialWidth/2,initialHeight/2,-2));
	Ogre::Entity* tEnt = mSceneMgr->createEntity("qr1","qrWall");
	tEnt->setMaterialName("tw_koton");
	tNode->attachObject(tEnt);
	qrNodes.push_back(tNode);
	qrEntities.push_back(tEnt);
*/
	//tNode=baseNode->createChildSceneNode("qrNode2",Vector3(192/2,3*192/2,0));
	//tEnt = mSceneMgr->createEntity("qr2","qrWall");
	//tEnt->setMaterialName("qr_intur_c");
	//tNode->attachObject(tEnt);
	//qrNodes.push_back(tNode);
	//qrEntities.push_back(tEnt);

	//tNode=baseNode->createChildSceneNode("qrNode3",Vector3(192/2,5*192/2,0));
	//tEnt = mSceneMgr->createEntity("qr3","qrWall");
	//tEnt->setMaterialName("tw_koton");
	//tNode->attachObject(tEnt);
	//qrNodes.push_back(tNode);
	//qrEntities.push_back(tEnt);

	#if SENSOR_INPUT
	initialize();
	shownBlack=false;
	shownWhite=false;
	signalBuffer=false;

	lowThreshold.resize(4);
	highThreshold.resize(4);
	midThreshold.resize(4);
	#endif



}
int pixelStep=5;
bool StructuredLight::keyPressed( const OIS::KeyEvent &arg )
{
	#if SENSOR_INPUT
	if (arg.key==OIS::KC_SPACE)
	{
		start=!start;
		shownBlack=false;
		shownWhite=false;
		signalBuffer=false;
		structurePanel->show();
		structurePanel->setMaterialName("pure_black");
		currentX=1;
		currentY=1;
		xUpdateCount=0;
		yUpdateCount=0;
		//baseNode->setVisible(false);
		for (int i=0;i<4;i++)
		{
			points.at(i)->x=0;
			points.at(i)->y=0;
		}
	
		
	}
	#else
	if (arg.key==OIS::KC_SPACE)
	{
		//start=!start;
		currentX=1;
		currentY=1;
		//transformPlane();
		structurePanel->show();
		mapPlane();
		//refillTexture(false,8);
	
		
	}
	else if (arg.key==OIS::KC_0)
		targetCorner=0;
	else if (arg.key==OIS::KC_1)
		targetCorner=1;
	else if (arg.key==OIS::KC_2)
		targetCorner=2;

	else if (arg.key==OIS::KC_3)
		targetCorner=3;
	else if (arg.key==OIS::KC_UP)
	{
		points.at(targetCorner)->y-=pixelStep;
		mCamera->setCustomProjectionMatrix(true,trueProjection);
		mapPlane();
	}
	else if (arg.key==OIS::KC_DOWN)
	{
		points.at(targetCorner)->y+=pixelStep;
		mCamera->setCustomProjectionMatrix(true,trueProjection);
		mapPlane();
	}
	else if (arg.key==OIS::KC_RIGHT)
	{
		points.at(targetCorner)->x+=pixelStep;
		mCamera->setCustomProjectionMatrix(true,trueProjection);
		mapPlane();
	}
	else if (arg.key==OIS::KC_LEFT)
	{
		points.at(targetCorner)->x-=pixelStep;
		mCamera->setCustomProjectionMatrix(true,trueProjection);
		mapPlane();
	}
	else if (arg.key==OIS::KC_H)
	{
		borderNode->setVisible(false);
		//videoNode->setVisible(false);
	}
	else if (arg.key==OIS::KC_U)
	{
		borderNode->setVisible(true);
		//videoNode->setVisible(true);
	}
	else if (arg.key==OIS::KC_K)
		videoNode->translate(0,5,0);
	else if (arg.key==OIS::KC_M)
		videoNode->translate(0,-5,0);
	else if (arg.key==OIS::KC_J)
		videoNode->scale(0,5,0);
	else if (arg.key==OIS::KC_N)
		targetCorner=1;
	#endif
	return BaseApplication::keyPressed(arg);
}

bool StructuredLight::keyReleased( const OIS::KeyEvent &arg )
{
	return BaseApplication::keyReleased(arg);
}
// OIS::MouseListener
bool StructuredLight::mouseMoved( const OIS::MouseEvent &arg )
{
	mouseX=arg.state.X.abs;
	mouseY=arg.state.Y.abs;
	return BaseApplication::mouseMoved(arg);
}
bool StructuredLight::mousePressed( const OIS::MouseEvent &arg, OIS::MouseButtonID id )
{
	if (currentTarget==0)
	{
		mCamera->setCustomProjectionMatrix(true,trueProjection);
	//	wall->setMaterialName("StructuredMaterial");
	}
	structurePanel->show();
	start=!start;
	currentX=1;
	currentY=1;
	

	return BaseApplication::mousePressed(arg,id);
}
bool StructuredLight::mouseReleased( const OIS::MouseEvent &arg, OIS::MouseButtonID id )
{

	return BaseApplication::mouseReleased(arg,id);
}

#if SENSOR_INPUT
void StructuredLight::setFlag(bool blackOrWhite)
{
	if (blackOrWhite)
	{
		shownBlack=true;
		signalBuffer=false;
	}
	else
	{
		shownWhite=true;
		signalBuffer=false;
	}
}
#endif
#define delay 1000
float timeBuffer=0;
bool StructuredLight::frameRenderingQueued(const Ogre::FrameEvent& evt)
{
	#if SENSOR_INPUT
	if (start)
	{
		if (timeBuffer>delay)
		{
			timeBuffer-=delay;
		if (!shownBlack)
		{
 			if (!signalBuffer)
			{
				//structurePanel->hide();
				structurePanel->setMaterialName("pure_black");
				refillTexture(true,0);
				signalBuffer=true;
			}
			else 
			{
				for (int i=0;i<4;i++)
				{
					lowThreshold.at(i)=readSensorValue(i);
				}
				signalBuffer=false;
				shownBlack=true;
				structurePanel->setMaterialName("pure_white");
			}
		}
		else if (!shownWhite)  
		{
			if (!signalBuffer)
			{			
				refillTexture(true,2);
				signalBuffer=true;
			}  
			else
			{
				for (int i=0;i<4;i++)
				{
					highThreshold.at(i)=readSensorValue(i);
					midThreshold.at(i)=(highThreshold.at(i)*5+lowThreshold.at(i)*5)/10;
				}
 				signalBuffer=false;
				shownWhite=true;
				structurePanel->setMaterialName("StructuredMaterial");
				refillTexture(true,1);
				currentY++;
			}
		}
		else
		{
		//	structurePanel->setMaterialName("StructuredMaterial");
			if (currentY<=maxPowerY)
			{
				if (signalBuffer)
				updatePoints(true);
				else
				signalBuffer=true;

				refillTexture(true,currentY);
				currentY++;
			}
			else if (currentY==maxPowerY+1)
			{
				updatePoints(true);
				signalBuffer=false;
				refillTexture(false,currentX);
				currentX++;
				currentY++;
			}
			else if (currentY==maxPowerY+2)
			{
				updatePoints(true);
				signalBuffer=false;
				currentY++;
				refillTexture(false,currentX);
				currentX++;
			}
			else if (currentX<=maxPowerX)
			{
				if (!signalBuffer)
				updatePoints(false);
				else
				signalBuffer=true;

				refillTexture(false,currentX);
				currentX++;
			}
			else if (currentX==maxPowerX+1)
			{
				updatePoints(false);
				signalBuffer=false;
				//refillTexture(false,currentX);
				currentX++;
			}
			else if (currentX==maxPowerX+2)
			{
				updatePoints(false);
				signalBuffer=false;
				//refillTexture(false,currentX);
				currentX++;
			}
			else
			{
				//for (int i=0;i<4;i++)
				//{
				//	points.at(i)->x/=4;
				//	points.at(i)->y/=4;
				//}

				start=!start;
				structurePanel->hide();
				mapPlane();
				timeBuffer=0;
			}
		}
	

		}
		else
			timeBuffer+=evt.timeSinceLastFrame*1000;
	}
	#else
	if (currentTarget==4)
		mapPlane();

	if (start)
	{
		if (currentY<=maxPowerY)
		{
			refillTexture(true,currentY);
			currentY++;
			updatePoint(&targetY);
		}
		else if (currentX<=maxPowerX)
		{
			refillTexture(false,currentX);
			currentX++;
			updatePoint(&targetX);
		}
		else
		{
			if (currentTarget<4)
			{
				points.at(currentTarget)->x=targetX;
				points.at(currentTarget)->y=targetY;
				targetY=0;
				targetX=0;
				currentTarget++;
				start=!start;
				structurePanel->hide();
			}
		}
	


	}
	#endif
	else
	{
		//Video processing ---------------------------
		if (videoWidth>0)
		{
			passedTime+=evt.timeSinceLastFrame*1000;
			if(passedTime>=frameDelay)//If enough time has passed for the next frame
			{
				IplImage* nextFrame=0;
				while (passedTime>=frameDelay)
				{
					passedTime-=frameDelay;//Update the time counter
					//Get the next frame
					nextFrame=cvQueryFrame(videoCapture);
					if (nextFrame==0)
					{
						reloadVideo();
						nextFrame=cvQueryFrame(videoCapture);
					}
				}
				convertIplToTexture(nextFrame,videoTexture);
			}
		}
		//Video processing ---------------------------
	}



	return BaseApplication::frameRenderingQueued(evt);

	
}
#if SENSOR_INPUT
void StructuredLight::updatePoints(bool yOrX)
{
	std::vector<int> sensors(4);

	for (int i=0;i<4;i++)
		sensors[i]=readSensorValue(i);

	if (yOrX)
	{
		for (int i=0;i<4;i++)
		{
			points.at(i)->y*=2;
			if (sensors[i]<midThreshold[i])
				points.at(i)->y+=1;
		}
		yUpdateCount++;
	}
	else
	{
		for (int i=0;i<4;i++)
		{
			points.at(i)->x*=2;
			if (sensors[i]<midThreshold[i])
				points.at(i)->x+=1;
		}
		xUpdateCount++;
	}

}
#endif
void StructuredLight::updatePoint(int* point)
{
	HardwarePixelBufferSharedPtr pixelBuffer = structuredTexture->getBuffer();//Get the Pixel Buffer for Texture
	pixelBuffer->lock(HardwareBuffer::HBL_DISCARD);						//Lock the buffer
	const PixelBox& pixelBox = pixelBuffer->getCurrentLock();			//Get the pixel box for data pointer
	unsigned char* pDest = static_cast<unsigned char*>(pixelBox.data);
	
	pDest = static_cast<unsigned char*>(pixelBox.data) + mouseY*pixelBox.rowPitch*4+mouseX*4;

	*point*=2;
	if (*pDest>128)
	{
		*point+=1;	
	}

	pixelBuffer->unlock();//Unlock the pixel buffer
	
}

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
    int main(int argc, char *argv[])
#endif
    {
        // Create application object
        StructuredLight app;

        try {
            app.go();
        } catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
            MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            std::cerr << "An exception has occured: " <<
                e.getFullDescription().c_str() << std::endl;
#endif
        }

        return 0;
    }

#ifdef __cplusplus
}
#endif
